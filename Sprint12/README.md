# **Яндекс.Практикум. Спринт 12**

# Тема 1. Типичные задачи с собеседований
https://contest.yandex.ru/contest/18338/problems/

## A. Значения функции:
На вход через пробел подаются числа a, x, b, c.
**Выведите одно число - значение функции в точке x.**

## B. Любители конференций:
В первой строке записан список id вузов длиной не больше 10100. 
Каждое из чисел находится в диапазоне от 0 до 10000. 
Во второй строке записано одно число - параметр k.

**Выведите k чисел (id вуза) через пробел, отсортированные по убыванию, начиная от максимального количества гостей от вуза на конференции.**


## C. Списочная форма:
На вход подается количество цифр числа Х, списочная форма неотрицательного числа Х и число K. 
Числа К и Х не превосходят 10000.
Нужно вернуть списочную форму числа X + K.

В первой строке - длина списочной формы числа X. 
На следующей строке - сама списочная форма с цифрами записанными через пробел. 
В последней строке записано число K.

**Выведите списочную форму числа X+K.**


## D. Убрать очки:
Дан список заработанных очков. Нужно удалить из него нули. 
Дополнительную память больше O(1) использовать нельзя.

В первой строке - одно число n. Во второй - n целых чисел через пробел.

**Напечатайте очки за все дни, где выигрыш был отличен от нуля.**


## E. Работа из дома:
На вход подается целое число в диапазоне от 0 до 10000.

**Выведите двоичное представление этого числа.**


## F. База данных:
Дан массив чисел, состоящий  из n целых чисел. 
Одно число встречается более одного раза. 
Нужно определить это число.

В первой строке записано число n, которое не превосходит 1000. 
В следующей строке через пробел записаны n целых чисел, 
каждое из которых также не превосходит 10000.

**Выведите одно число.**


## G. Анаграммы:
Два слова - каждое на отдельной строке.
Слова состоят из строчных букв латинского и русского алфавитов.

**Слово True, если слова являются анаграммами друг друга, слово False - если не являются.**


## H. Палиндром
Решение должно работать за O(N), где N - длина строки на входе. 
Дополнительную память более O(1) использовать нельзя.

В единственной строке записана фраза или слово. Буквы могут быть только латинские.
Учитываются только буквы и цифры, заглавные и строчные буквы считаются одинаковыми.

**Выведите True, если фраза является палиндромом и False, если не является.**


## I. Двоичная система:
Два числа записаны в двоичной системе счисления. 
Нужно вывести их сумму, также в двоичной системе. 
Встроенную в язык программирования возможность сложения двоичных чисел применять нельзя.

Два числа в двоичной системе счисления, каждое на отдельной строке.

**Одно число в двоичной системе счисления.**


## J. Обеды: 
На вход подается непустой массив целых чисел. 
Каждое из них, за исключением одного, встречается 2 раза. 
Размер массива не превосходит 10000. Числа по модулю не больше 10000. 
Нужно выяснить, кто не такой, как все!

В первой строке записано число n. Во второй строке через пробел записаны n чисел. 
Длина массива и каждое из чисел не превосходят 10000.

**Выведите единственное число, соответствующее id отличившегося сотрудника**


## K. Единицы: 
Дано целое положительное число. 
Нужно посчитать, сколько 1 встречается в двоичной записи этого числа.

На вход подается число в диапазоне от 1 до 10000

**Выведите одно число - количество единиц.**


## L. Лишняя буква: 
Есть 2 строки s и t, состоящие только из строчных букв. 
Строка t получена перемешиванием букв строки s и добавлением 1 буквы в случайную позицию. 
Нужно найти добавленную букву.

На вход подаются строки s и t, разделенные переносом строки.

**Выведите лишнюю букву.**


## M. Частоты:
На вход подается строка длиной от 1 до 10000 символов. 
Нужно отсортировать её в порядке частот букв по встречаемости. 
Заглавные и строчные буквы считаются разными. Если частота одинаковая, 
нужно применить вторичную сортировку лексикографически.

Одна строка длиной не более 10000 символов.

**Строка, в которой символы отсортированы в порядке убывания частотности.**


## N. Степень четырех:
На вход подается целое число в диапазоне от 1 до 10000.
**True, если число является степенью четырех, False - в обратном случае.**


## O. И снова Вася:
В первой строке записаны id пользователей с первого сервера через пробел, в конце - k нулей. 
Во второй строке записано число m - количество id, 
пришедших с первого сервера (без учета нулей в конце списка). 
В третьей - число k - которое, помимо количества нулей, 
также является длиной списка пользователей со второго сервера. 
В последней строке - id со второго сервера (k штук).

Все id не превосходят 10000, числа m и k также не превосходят 10000
Формат вывода

**В одной строке через пробел выведите элементы получившегося id в отсортированном порядке.**


## P. Комбинации:
На клавиатуре старых мобильных телефонов каждой цифре соответствовало несколько букв. 
Примерно так:
2:'abc', 3:'def', 4:'ghi', 5:'jkl', 6:'mno', 7:'pqrs', 8:'tuv', 9:'wxyz'
Вам известно в каком порядке были нажаты клавиши телефона, без учета повторов. 
Напечатайте все комбинации букв, которые можно набрать такой последовательностью нажатий.

На вход подается строка, состоящая из цифр 2-9 включительно.

**Выведите все возможные комбинации букв через пробел.**


## Q. Статистика:
В первой строке записано число n. 
В следующей строке через пробел записаны n целых чисел. 
Числа находятся в диапазоне от -10000 до 10000.

**Выведите максимальное положительное произведение** заработанных за три дня очков 
среди троек дней, в которые их сумма равна нулю. 
Если троек, удовлетворяющих условиям, нет, нужно вывести -1



# Тема 2. Базовые структуры данных
https://contest.yandex.ru/contest/18337/problems/

## A. Кружки
Напишите код для решения задачи про поиск кружков, которые посещает хотя бы один ученик. 
Ваше решение должно задействовать O(1) дополнительной памяти 
(то есть помимо памяти, выделенной под массив visited_optional_courses)

В первой строке записано количество кружков n, целое число, 
не превосходящее 10000 В следующих n строках записаны названия кружков.

**Выведите уникальные названия кружков** по одному на строке, 
в порядке появления во входных данных


# B. Мониторинг
Есть матрица размера m × n. Нужно написать функцию, которая её транспонирует.
Транспонированная матрица получается из исходной замены строк на столбцы.

В первой строке задано число n - количество строк матрицы. 
Во второй строке - m - число столбцов, m и n не превосходит 1000. 
В следующих n строках задана матрица. Числа в матрице по модулю не превосходят 1000.

**Напечатайте транспонированную матрицу в том же формате**

# C. Подстроки:
На вход подается строка. Нужно определить длину наибольшей подстроки, 
которая не содержит повторяющиеся символы.

Одна строка, состоящая из латинских букв. Длина строки не превосходит 10000.

**Одно число - ответ на задачу.**

# D. Соседи:
Дана матрица. Нужно написать функцию, которая для элемента возвращает 
всех его соседей. Соседним считается элемент, находящийся от текущего 
на одну ячейку влево, вправо, вверх или вниз. Диагональные элементы 
соседними не считаются.

В первой строке задано n - количество строк матрицы. 
Во втрой - m - количество столбцов. Числа m и n не превосходят 1000. 
В следующих n строках задана матрица. Элементы матрицы - целые числа, 
по модулю не превосходящие 1000. В последних двух строках записаны 
координаты элемента (индексация начинается с нуля), соседей которого 
нужно найти.

**Напечатайте нужные числа в возрастающем порядке через пробел.**

# E. Список дел
Васе нужно распечатать свой список дел на сегодня. 
Помогите ему: напишите функцию, которая печатает все его дела. 
Известно, что дел у Васи не больше 5000.

**Функция должна напечатать элементы списка по одному в строке.**

# F. Нелюбимое дело:
Вася размышляет, что бы такое из списка не делать. 
Но, кажется, все пункты очень важные! 
Вася решает загадать число и удалить дело, которое идёт под этим номером. 
Список дел представлен в виде односвязного списка. 

**Напишите функцию solution, которая принимает на вход голову списка**
**и номер удаляемого дела и возвращает голову обновлённого списка.**

# G. Заботливая мама
Мама Васи хочет знать, что сын планирует делать и когда. 
Помогите ей: напишите функцию solution, определяющую индекс первого вхождения 
передаваемого ей на вход значения в связном списке, если значение присутствует.

Функция на вход принимает голову односвязного списка и элемент, 
который нужно найти.

**Функция возвращает индекс первого вхождения искомого элемента**
в список(индексация начинается с нуля). 
Если элемент не найден, нужно вернуть -1. 

# H. Все наоборот:
Вася решил запутать маму —– делать дела в обратном порядке. 
Список его дел теперь хранится в двусвязном списке. 
Напишите функцию, которая вернёт список в обратном порядке.

Функция принимает на вход единственный аргумент — голову двусвязного списка.

**Функция должна вернуть голову развернутого списка.**

# I. Стек - Max
Нужно реализовать класс StackMax, который поддерживает операцию определения 
максимума среди всех элементов в стеке. Класс также должен поддерживать 
все операции, реализованные в классе Stack, из урока. 
При этом в классе StackMax может быть реализовано не более трёх методов.

Стек может содержать только данные типов, поддерживающих операцию сравнения. 
Иначе операция поиска максимума будет некорректной.

В первой строке записано одно число n - количество команд. 
n не превосходит 1000. В следующих n строках идут команды. 
Команды могут быть следующих видов:
push x - добавить число x в стек
pop - удалить число с вершины стека
get_max - напечатать максимальное число в стеке


Для каждой команды get_max напечатайте результат её выполнения. 
Если стек пустой, для команды get_max напечатайте None. 
Если происходит удаление из пустого стека - напечатайте error. 

# J. Стек - MaxEffective

Реализуйте класс StackMaxEffective, поддерживающий операцию определения 
максимума среди элементов в стеке. Сложность операции должна быть O(1). 
Для пустого стека операция должна возвращать None. 
При этом push и pop также должны выполняться за константное время.

В первой строке записано одно число - количество команд, 
оно не превосходит 1000. Далее идут команды по одной в строке. 
Команды могут быть следующих видов:
push x - добавить число x в стек
pop - удалить число с вершины стека
get_max - напечатать максимальное число в стеке

Для каждой команды get_max напечатайте результат её выполнения. 
Если стек пустой, для команды get_max напечатайте None. 
Если происходит удаление из пустого стека - напечатайте error. 

# K. Уникальный Стек:
Реализуйте класс StackSet, который хранит только уникальные элементы. 
При этом операция добавления элемента в стек должна выполняться за O(1).

В первой строке записано одно число - количество команд. 
Далее идут команды по одной на строке. Команды могут быть следующих видов:
push x - добавить число x в стек
pop - удалить число с вершины стека
peek - напечатать число с вершины стека (без удаления)
size - узнать размер стека

Если стек пуст при вызове команд pop и peak нужно вывести на печать error.

Для каждой команды size напечатайте результат её выполнения. 
Если происходит удаление из пустого стека - напечатайте error.

# L. Скобочная последовательность
Вот какую задачу Тимофей предложил на собеседовании одному из кандидатов. 
Если вы с ней еще не сталкивались, то наверняка столкнётесь — она довольно 
популярная.

Дана скобочная последовательность. Нужно определить, правильная ли она.
Будем придерживаться такого определения:
- пустая строка — правильная скобочная последовательность;
- правильная скобочная последовательность, 
взятая в скобки одного типа, — правильная скобочная последовательность;
- правильная скобочная последовательность с приписанной слева или справа 
правильной скобочной последовательностью — тоже правильная.

На вход подается последовательность из скобок трёх видов: [], (), {}.

Напишите функцию is_correct_bracket_seq, которая принимает на вход 
скобочную последовательность и возвращает True, 
если последовательность правильная, иначе False.

На вход подается одна строка, содержащая скобочную последовательность.


# M. Очередь
Перед Тимофеем стоит задача написать несколько реализаций собственной очереди, 
так как доступные на рынке варианты для проекта не подходят. 
Требования к первой вот такие: класс должен называться MyQueue(), 
поддерживать операции добавления, удаления, получения элемента, 
определение текущего размера, и метод, показывающий, пуста ли очередь или нет. 
Реализована структура данных должна быть на основе массива.

В первой строке записано одно число - количество команд, оно не превосходит 5000.
Далее идут команды по одной в строке. Команды могут быть следующих видов:
push x - добавить число x в очередь
pop - удалить число из очереди и напечатать его
peek - напечатать первое число в очереди
size - вернуть размер очереди

Для каждой команды size, peek напечатайте результат её выполнения. 
Если очередь пуста, для команды peek напечатайте None. 
Если происходит удаление из пустой очереди - напечатайте None. 
"""

# N. Ограниченная очередь
Далее Тимофею нужно написать класс MyQueueSized(), 
который принимает параметр max_size, означающий максимально допустимое 
количество элементов в очереди.

В первой строке записано одно число - количество команд, оно не превосходит 5000. 
Во второй строке задан максимально допустимый размер очереди, 
он не превосходит 5000. Далее идут команды по одной на строке. 
Команды могут быть следующих видов:
push x - добавить число x в очередь
pop - удалить число из очереди и вывести на печать
peek - напечатать первое число в очереди
size - вернуть размер очереди

При превышении допустимого размера очереди нужно вывести "error". 
При вызове операции pop для пустой очереди нужно вернуть None.

# P. Списочная очередь
Любимый вариант очереди Тимофея - очередь, 
написанная с использованием связного списка. 
Помогите ему с реализацией. Очередь должна поддерживать методы get, put, size.

В первой строке записано количество команд n - целое число, не превосходящее 1000.
В каждой из следующих n строк записана команда: get, put, или size.

При вызове метода get напечатайте возвращаемое значение. 
Если метод get вызывается у пустой очереди, нужно напечатать 'error'. 
При вызове метода size - вывести размер очереди. 

# Q. Дек
Гоша решил реализовать структуру данных Дек, максимальный размер 
которого определяется заданным числом. 
Методы push_back, push_front, pop_front, pop_back работали корректно. 
Но, если в деке было много элементов, программа работала очень долго. 
Дело в том, что не все операции выполнялись за O(1). 
Помогите Гоше! Напишите эффективную реализацию.

В первой строке записано количество команд n - целое число, не превосходящее 5000. 
Во второй строке записано число m - максимальный размер стека. 
Он не превосходит 1000. 
В следующих n строках записана одна из команд:
push_back value
push_front value
pop_front
pop_back
value - целое число, по модулю не превосходящее 1000.

При вызове команд pop_front и pop_back нужно вывести возвращаемое значение. 
Если они вызываются для пустого стека - напечатайте 'error'. 
Если команда push_back или push_front вызывается для стека, 
размер которого равен максимально возможному, тоже нужно вывести 'error'. 


# Финальные задачи
https://contest.yandex.ru/contest/18357/problems/

## A. Калькулятор


Задание связано с обратной польской нотацией. Она используется для парсинга арифметических выражений. По сравнению с другим приемом, применяемым для данной задачи — использованием дерева операций, она является более компактной, так как в ней не используются скобки. Еще её иногда называют постфиксной нотацией.

В постфиксной нотации операнды расположены перед знаками операций.

Пример 1:  
3 4 +  
будет равно 7, и означает 3 + 4

Пример 2:  
10 2 4 * -  
будет равно 2, и означает 10 - 2 * 4

Разберем последний пример подробнее:

Знак * стоит сразу после чисел 2 и 4, значит к ним нужно применить операцию, которую этот знак обозначает, то есть перемножить эти два числа. В результате получим 8

После этого выражение приобретет вид:

10 8 -

Операцию минус нужно применить к двум идущим перед ней числам, то есть 10 и 8. В итоге получаем 2.

Рассмотрим алгоритм более подробно. Для его реализации будем использовать стек.

Для вычисления значения выражения, записанного в обратной польской нотации, нужно считывать выражение слева направо и придерживаться следующих шагов:

1. Обработка входного символа: - Если на вход подан операнд, он помещается на вершину стека. - Если на вход подан знак операции, она выполняется над требуемым количеством значений из стека, взятых в порядке добавления. Результат выполненной операции помещается на вершину стека. 
2. Если входной набор символов обработан не полностью, перейти к шагу 1. 
3. После полной обработки входного набора символов результат вычисления выражения находится в вершине стека.


### Формат ввода
В единственной строке дано выражение, записанное в обратной польской нотации. Числа и арифметические операции отделены друг от друга пробелами.

На вход могут подаваться операции: +, -, *, / и числа, по модулю не превосходящие 10000.

Гарантируется, что значение промежуточных выражений в тестовых данных по модулю не больше 50000.

### Формат вывода 
Единственное число - значение выражения.

## B. Циклы
В качестве второго задания финального проекта нужно написать программу, которая определяет, есть ли цикл в связном списке.

На вход функция принимает голову списка, на выходе должна выдать True, если в списке содержится цикл, иначе — False. Размер дополнительной памяти, к которой обращается функция, не должен превышать О(1). 

### Формат ввода
В этой задаче вам нужно реализовать только функцию с решением, считывать входные данные не нужно.
Функция должна принимать на вход голову связного списка.
Класс, представляющая узел списка выглядит так:

    class Node:  
        def __init__(self, value, next=None):  
            self.value = value  
            self.next = next  
        def __repr__(self):  
            return self.value

Ваша функция должна называться hasCycle.

### Формат вывода
Функция должна возвращать булево значение.

